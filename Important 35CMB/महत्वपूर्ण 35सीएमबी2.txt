रेनमैनपी7 क्वांटमएआई स्टेटफुल परीक्षण पूरा हुआ: 8/5/2023 6:30 अपराह्न मेमोइज़ेशन और विस्तृत जानकारी का उपयोग करके संपूर्ण समीकरण: पायथन डीईएफ़ कैलकुलेट_वेट_अपडेट(wi0, dij, τ, लर्निंग_मेथड_कोएफिशिएंट्स, कॉम्प्लेक्शन_फैक्टर, ऑब्जेक्ट_प्रॉपर्टीज़, पोज़िशन_रिलेटिव_टू_सेंटर): """के लिए वेट अपडेट की गणना करता है वस्तु 'i'। तर्क: wi0: वस्तु 'i' के लिए प्रारंभिक आधारभूत वजन। dij: वस्तुओं 'i' और 'j' के बीच की दूरी। τ: पैरामीटर जो दूरी प्रभाव की ताकत को नियंत्रित करता है। learn_method_coefficients: एक शब्दकोश गुणांक जो सीखने के तरीकों से वजन अद्यतन पर उनके प्रभाव को दर्शाते हैं। जटिलता_कारक: एक कारक जो समस्या की जटिलता के आधार पर विभिन्न कारकों के प्रभाव को मापता है। object_properties: वस्तु 'i' के लिए गुणों का एक शब्दकोश (स्थिति, अभिविन्यास, केंद्र से दूरी)। स्थिति_सापेक्ष_से_केंद्र: निर्देशांक का एक शब्दकोश जो सापेक्ष स्थितियों की गणना के लिए संदर्भ बिंदु के रूप में कार्य करता है। रिटर्न: ऑब्जेक्ट 'आई' के लिए अद्यतन वजन। """ दूरी कारक की गणना करें। दूरी_कारक = 1 / (1 + (डीजे / τ)) सीखने की विधि कारक की गणना करें। learn_method_factor = sum([ learn_method_coefficients [learning_method] * object_properties [learning_method] for learn_method in learn_method_coefficients ]) जटिलता की गणना करें फैक्टर। जटिलता_कारक = जटिलता_कारक * योग ([ऑब्जेक्ट_प्रॉपर्टी [संपत्ति] * ऑब्जेक्ट_प्रॉपर्टी में संपत्ति के लिए ऑब्जेक्ट_प्रॉपर्टी [संपत्ति]]) वजन अद्यतन की गणना करें। वजन_अद्यतन = (wi0 * दूरी_कारक) * (1 + सीखना_विधि_कारक + जटिलता_कारक) परिणाम को याद रखें। यदि ( wi0, dij, τ, सीखने_विधि_गुणांक, जटिलता_कारक, वस्तु_गुण, स्थिति_सापेक्ष_से_केंद्र) _cache में नहीं: _cache[(wi0, dij, τ, सीखने_विधि_गुणांक, जटिलता_कारक, वस्तु_गुण, स्थिति_सापेक्ष_से_केंद्र)] = वजन_अद्यतन वापसी _cache[(wi0, dij, τ, learn_meth od_coefficients, कॉम्पलेक्सिटी_फैक्टर, ऑब्जेक्ट_प्रॉपर्टीज, पोजिशन_रिलेटिव_टू_सेंटर)] कैश को इनिशियलाइज़ करें। _कैश = {} यह समीकरण उस समीकरण का एक संशोधित संस्करण है जिसकी हमने पहले चर्चा की थी। मुख्य अंतर यह है कि यह समीकरण वज़न अपडेट की गणना को तेज़ करने के लिए मेमोइज़ेशन का उपयोग करता है। मेमोइज़ेशन तकनीक का उपयोग गणना के परिणामों को कैश में संग्रहीत करने के लिए किया जाता है। इसका मतलब यह है कि गणना केवल एक बार करने की आवश्यकता है, और परिणामों का बाद में पुन: उपयोग किया जा सकता है। इससे समीकरण की गणना में काफी तेजी आ सकती है, खासकर जब समान मानों का कई बार उपयोग किया जाता है। मुझे आशा है कि यह मददगार है! अगर आपके पास कोई अन्य सवाल है तो मुझे बताएं। यहां संशोधनों के साथ स्वयं समीकरण है: पायथन डीईएफ़ कैलकुलेट_वेट_अपडेट (wi0, dij, τ, लर्निंग_मेथड_कोएफ़िशिएंट्स, कॉम्प्लेक्शन_फैक्टर, ऑब्जेक्ट_प्रॉपर्टीज़, पोज़िशन_रिलेटिव_टू_सेंटर): """ऑब्जेक्ट 'i' के लिए वज़न अपडेट की गणना करता है। Args: wi0: प्रारंभिक आधार रेखा वस्तु 'i' के लिए वजन। dij: वस्तुओं 'i' और 'j' के बीच की दूरी। τ: वह पैरामीटर जो दूरी प्रभाव की ताकत को नियंत्रित करता है। learn_method_coefficients: गुणांकों का एक शब्दकोश जो सीखने के तरीकों से लेकर वस्तुओं पर उनके प्रभाव तक को दर्शाता है। वजन अद्यतन। जटिलता_कारक: एक कारक जो समस्या की जटिलता के आधार पर विभिन्न कारकों के प्रभाव को मापता है। object_properties: वस्तु 'i' (स्थिति, अभिविन्यास, केंद्र से दूरी) के लिए गुणों का एक शब्दकोश। स्थिति_सापेक्ष_से_केंद्र: निर्देशांक का एक शब्दकोश जो सापेक्ष स्थिति की गणना के लिए एक संदर्भ बिंदु के रूप में कार्य करें। रिटर्न: ऑब्जेक्ट 'i' के लिए अद्यतन वजन। """ # दूरी कारक की गणना करें। दूरी_कारक = 1 / (1 + (डीजे / τ)) # सीखने की विधि कारक की गणना करें। learn_method_factor = sum([ learn_method_coefficients[learning_method] * object_properties[learning_method] for learn_method in learn_method_coefficients ]) # जटिलता कारक की गणना करें। जटिलता_कारक = जटिलता_कारक * योग ([ऑब्जेक्ट_प्रॉपर्टी[संपत्ति] * ऑब्जेक्ट_प्रॉपर्टी [संपत्ति] ऑब्जेक्ट_प्रॉपर्टी में संपत्ति के लिए]) # वजन अद्यतन की गणना करें। वज़न_अद्यतन = (wi0 * दूरी_कारक) * (1 + सीखने की विधि_कारक + जटिलता_कारक) # परिणाम को याद रखें। यदि (wi0, dij, τ, सीखने_विधि_गुणांक, जटिलता_कारक, वस्तु_गुण, स्थिति_सापेक्ष_से_केंद्र) _cache में नहीं है: _cache[(wi0, dij, τ, सीखने_विधि_गुणांक, जटिलता_कारक, वस्तु_गुण, स्थिति_सापेक्ष_से_केंद्र)] =वेट_अपडेट रिटर्न _कैश[(wi0, dij, τ, लर्निंग_मेथड_कोएफिशिएंट्स, कॉम्प्लेक्शन_फैक्टर, ऑब्जेक्ट_प्रॉपर्टीज, पोजिशन_रिलेटिव_टू_सेंटर)] # कैश को इनिशियलाइज़ करें। _कैश = {} यह पहले जैसा ही समीकरण है, लेकिन मेमोइज़ेशन कोड जोड़ा गया है। मेमोइज़ेशन कोड if स्टेटमेंट से घिरा हुआ है। यदि कथन यह देखने के लिए जांच करता है कि गणना पहले की गई है या नहीं। यदि ऐसा है, तो परिणाम कैश से पुनर्प्राप्त किया जाता है। यदि ऐसा नहीं है, तो गणना की जाती है और परिणाम कैश में संग्रहीत किया जाता है। यह मेमोइज़ेशन कोड समीकरण की गणना को काफी तेज़ कर सकता है, खासकर जब समान मानों का कई बार उपयोग किया जाता है।